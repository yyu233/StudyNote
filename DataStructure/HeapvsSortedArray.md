ğšğš’ğš—ğš-ğš–ğš’ğš— (resp. ğšğš’ğš—ğš-ğš–ğšŠğš¡), ğšğšğš•ğšğšğš-ğš–ğš’ğš— (resp. ğšğšğš•ğšğšğš-ğš–ğšŠğš¡) and ğš’ğš—ğšœğšğš›ğš are the three most important operations of a min-heap (resp. max-heap), and they usually have complexity of O(1), O(logğ‘›) and O(logğ‘›) respectively if you implement a min/max-heap by a binary tree.

Now suppose instead you implement a min-heap by a sorted (non-decreasing) array (The case for max-heap is similar). ğšğš’ğš—ğš-ğš–ğš’ğš— and ğšğšğš•ğšğšğš-ğš–ğš’ğš— are of O(1) complexity if ğš’ğš—ğšœğšğš›ğš is not required in your application, since you can maintain a pointer ğ‘ that always points to the minimum element in your array. When the minimum element is removed, you just need to move ğ‘ one step to the next element in the array.

Dealing with insertion in a sorted array is not trivial. Given a new element ğ‘’, we can use binary search to locate its position in the array to insert it. But the point is that if you want to insert it there, you have to move a lot of old elements (can be O(ğ‘›)) around to make a vacancy for the new element to reside. This is quite inefficient for most applications. You may also choose to re-sort the array after an element is inserted, this requires O(ğ‘›logğ‘›) time however.
